## Welcome to my homepage!

Here is a collection of works from CSCI 260!
### "The Pragmatic Programmer" Chapter Two thoughts.

The Second Chapter of the "Pragmatic Programmer" heavily covers that duplication in your code is one of the fastest ways to wreck a project.  This really hits home for me with some of the points that it brings up because some of the mentioned issues have been of concern for me in the past to the point where I spent hours pouring over some code that was simply not working because of a few values had not been updated or something similar.  One thing that really stuck with me is the idea of Impatient duplication as in the past I have done this as a way to create a 'duct tape' fix for a method or part of a program that I want to test, often times this would come back to bite me rather badly.  The chapter also speaks breifly on the principles of documentation, documentation has always been a weak point of mine and there are cocuntless times where I have gone back to work on a project and completley lose track of what exactly is going on in the code that I wrote mere days ago.  Going forward this is something I would really like to work on.

The thing that probably stood out to me the most in chapter two is the idea of orthogonality.  To simplify my understanding that I got from this section of the chapter it is eliminating as many connections as possible so that a method is easier to understand and find issues if something happens to wrong.  This seems like one of teh most useful pieces of information form the chapter as it can help to speed up development due to a shorter time spent problem solving.

There is really nothing in this chapter that I would disagree with outright.  The only issue that I see coming from some of the concepts introduced is that if all of these are taken into account in a large degree then I feel like that would deffinitly have the potential to bloat developement time and the proccess in general.

On a final side note on the chapter I loved the anecdotes and metaphors included in this chapter, like that of the helicopter for orthogonality or tracer rounds from a machine gun for the tracer bullets concept.  Drawing from some of the experiences I have had in the military has helped me to really understand these concepts better.


__/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/__


### "The Pragmatic Programmer" Chapter One thoughts.

 After reading the first chapter of "The Pragmatic Programmer" by Andrew Hunt, and David Thomas, I have to say I am plesantly surprised.  Out of all of the computer science reading I have read over the past year and a half of college this is easily the most aproachable thing I have read yet, at least based off of the first chapter.  Probably my favorite thing about the text is the formatting.  The text has been designed in such a way that it is easy to read and pick out highly important information, it is fantastic.  Another thing that I love about the text is how many, if not all of the examples in the text are presented as metaphors, it makes it a lot easier to digest the information as it is read.  The only thing that I would disagree with on the text is not the general contents, it was all fairly easy to understand and extreemly good tips or advice, it is that there is that some of the metaphors or short storys can seems a little drawn out.  Overall I am actualy looking forward to seeing more of what the text has, something I have almost never said about a piece of required reading before.


__/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/__


### Why I am Taking software engineering.

I am taking software engineering for a few reasons.  Probably the most aparent and insignificant reason for me taking the class is that it is part of the requirements for my major, however I am guessing this is the case for all of the other studentds in the class.  Far more important to me is that I learn how to better myself as a developer, whether this is in my style, tools I have at my disposal, or any other potential outlets that will come up over the course of the class.

The main take aways that I hope to gain from the course are for one a much better understanding of git and using the console to manipulate hardware and repository systems. I have actualy really enjoyed all of the experience I have had with git so far due to the fact that it does not feel like an impossible task compare to some of the projects I have worked on in the past, every issue I have run into I have managed to rectify the issues after a few minutes of carefull analysis and the occasional Google search, even if I have had to walk away for a minute due to frustraition.  The other main take away that I would like to get from the course is a better understanding of java and C++, my experiences in the past have not always been the most enjoyable and I feel like that has hampered some of my learning ability with them.


__/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/__


### What Software Engineering means to me.

To me Software Engineering is the creation of code to efficiently acheive certain goals set at the begining of a project.  This does not mean however that changes cannot be made to the plan that is initialy created, sometimes a project evolves outside of the original parameters that were set, new features to be added and such.

It is also worth mentioning that to me the most important part of software engineering is efficiency, sure it is great if there is an easy to navigate UI or features upon features, however if the intial goals of the project are impaired by feature creep or other issues then it becomes a problem.


__/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/__
