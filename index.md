## Welcome to my homepage!

Here is a collection of works from CSCI 260!

### "The Pragmatic Programmer" Chapter Seven thoughts.

Chapter seven begins in the most relateable statement I have ever read in reguards to CS, at least for me, "Do you ever get the feeling that your project is doomed, even before it starts?"  I have this feeling all to often in reguards to CS unfortunatly, however thankfully this chapter is based on the ideals of preplanning to avoid a majority of these issues (at least that is the hope).

The first section of the chapter covers "digging for requirements", and how it is important to set goals and the mission before commiting to begining a project.  Often times in my experiences so far many requirements are procided in project guidlines and what not, however there are almost always 'hidden requirements that it is imperative to find else the project not achieve the desired end state.  It is also emphisized how important it is to document the project requirements, better organization seems to equal a more functional end product.

The chapter also goes on to say that overspecification can lead to bloating in design documentation and not leaving enough room to work with interpritation wise which can lead to further issues or less effective code.  The same goes for not following design documentation well enough and not having defined limits which can lead to a project growing quite a bit out of its original scope and pushing back deadlines.

The next major section of the chapter is on problem solving.  It is emphisized that there is always a solution to whatever issue is faced, the right aproach just needs to be taken.  This correct aproach is often found by looking through the constraints and limitations of the project at hand and findig what you as a programmer can work with.  There is also the idea that It is important to find what the problem at hand actualy is as perceived issues are not always the cause, sometimes it is a less likely canidate.

The last few sections finish out by going through and explaining different faccets of development and how following, or not following procedure can be helpful in the overall proccess.  While I do not believe this portion of the chapter to be as helpful as the previous it still has a good amount to offer.

Overall though I feel that the chapter can be very useful, it is my opinion that even if all of the tips and steps that are provided in the text are followed that it does not really do much in the end to ensure smooth developement.  I feel this way due to past experience where I have laid out as much preperatory work as possible and then things still go amazingly wrong (honestly it feels like this more often than not).

### "The Pragmatic Programmer" Chapter Four thoughts.

Chapter 4 begins with a very simple statement and idea, 'you cannot write perfect software'.  This in and of itself makes me feel so much better about all of my coding so far...

The first real thing that the chapter covers is the ideas of designing by and designing with contract.  Improperly goinging about the early stages of a project often times leads to my own undoing in a lot of coding projects that I have worked on, to the point where it was easier to just go back, write it all out on paper and then revisit it.  I believe that the advice in this section of the text has a lot to offer in my ventures going forward based upon this.

The next section essentialy covers the idea of failure.  By failure I mean those caused by either error or decisions made in the design proccess.  Thankfully errors and crashes can be spun into a positive light, when they happen early on you avoid problems potentialy compounding, nothing is more annoying than a bug nested within line upon line of interconnected code, however maybe that says something about my planning skills.

I really apriciated the section of the chapter on assertive programming, mainly because it can be summed up to a mindset that I find myself in more often than now, 'whatever can go wrong... will.'

The final two sections of the chapter I feel compliment eachother rather well, the first being the usage of exceptions in code and then second on balence in code.  They work well together due to the fact that when used in moderation, neither really need to be worried about, however if exceptions are addded for no reason, code is not terminated after it finishes, or whatever else may go wrong occures it can become catastrophic.  This the need for a reasoned aproach and at least some foresight when creating code.

Chapter 4 I feel is unique because almost everything that is in the chapter can be pulled to improve the pre-planning stage of production on a project.  I view the chapter as almost being a lesson on pessimisim, whatever can go wrong on a project will, so get ready and preplan to the point where it is not an issue.


__/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/__


### "The Pragmatic Programmer" Chapter Two thoughts.

The Second Chapter of the "Pragmatic Programmer" heavily covers that duplication in your code is one of the fastest ways to wreck a project.  This really hits home for me with some of the points that it brings up because some of the mentioned issues have been of concern for me in the past to the point where I spent hours pouring over some code that was simply not working because of a few values had not been updated or something similar.  One thing that really stuck with me is the idea of Impatient duplication as in the past I have done this as a way to create a 'duct tape' fix for a method or part of a program that I want to test, often times this would come back to bite me rather badly.  The chapter also speaks breifly on the principles of documentation, documentation has always been a weak point of mine and there are cocuntless times where I have gone back to work on a project and completley lose track of what exactly is going on in the code that I wrote mere days ago.  Going forward this is something I would really like to work on.

The thing that probably stood out to me the most in chapter two is the idea of orthogonality.  To simplify my understanding that I got from this section of the chapter it is eliminating as many connections as possible so that a method is easier to understand and find issues if something happens to wrong.  This seems like one of teh most useful pieces of information form the chapter as it can help to speed up development due to a shorter time spent problem solving.

There is really nothing in this chapter that I would disagree with outright.  The only issue that I see coming from some of the concepts introduced is that if all of these are taken into account in a large degree then I feel like that would deffinitly have the potential to bloat developement time and the proccess in general.

On a final side note on the chapter I loved the anecdotes and metaphors included in this chapter, like that of the helicopter for orthogonality or tracer rounds from a machine gun for the tracer bullets concept.  Drawing from some of the experiences I have had in the military has helped me to really understand these concepts better.


__/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/__


### "The Pragmatic Programmer" Chapter One thoughts.

 After reading the first chapter of "The Pragmatic Programmer" by Andrew Hunt, and David Thomas, I have to say I am plesantly surprised.  Out of all of the computer science reading I have read over the past year and a half of college this is easily the most aproachable thing I have read yet, at least based off of the first chapter.  Probably my favorite thing about the text is the formatting.  The text has been designed in such a way that it is easy to read and pick out highly important information, it is fantastic.  Another thing that I love about the text is how many, if not all of the examples in the text are presented as metaphors, it makes it a lot easier to digest the information as it is read.  The only thing that I would disagree with on the text is not the general contents, it was all fairly easy to understand and extreemly good tips or advice, it is that there is that some of the metaphors or short storys can seems a little drawn out.  Overall I am actualy looking forward to seeing more of what the text has, something I have almost never said about a piece of required reading before.


__/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/__


### Why I am Taking software engineering.

I am taking software engineering for a few reasons.  Probably the most aparent and insignificant reason for me taking the class is that it is part of the requirements for my major, however I am guessing this is the case for all of the other studentds in the class.  Far more important to me is that I learn how to better myself as a developer, whether this is in my style, tools I have at my disposal, or any other potential outlets that will come up over the course of the class.

The main take aways that I hope to gain from the course are for one a much better understanding of git and using the console to manipulate hardware and repository systems. I have actualy really enjoyed all of the experience I have had with git so far due to the fact that it does not feel like an impossible task compare to some of the projects I have worked on in the past, every issue I have run into I have managed to rectify the issues after a few minutes of carefull analysis and the occasional Google search, even if I have had to walk away for a minute due to frustraition.  The other main take away that I would like to get from the course is a better understanding of java and C++, my experiences in the past have not always been the most enjoyable and I feel like that has hampered some of my learning ability with them.


__/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/__


### What Software Engineering means to me.

To me Software Engineering is the creation of code to efficiently acheive certain goals set at the begining of a project.  This does not mean however that changes cannot be made to the plan that is initialy created, sometimes a project evolves outside of the original parameters that were set, new features to be added and such.

It is also worth mentioning that to me the most important part of software engineering is efficiency, sure it is great if there is an easy to navigate UI or features upon features, however if the intial goals of the project are impaired by feature creep or other issues then it becomes a problem.


__/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/__
